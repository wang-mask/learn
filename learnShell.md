# shell学习

## 全局知识
1. 命令行开头由[用户名@主机名 当前工作目录] $（若提示符为#则为超级权限用户）
2. command -options arguments（短命令使用-，长命令使用—）
3. 多个命令可放在同一行，使用；分隔即可
4. ～代表当前用户的家目录
5. 双引号中， shell 使用的特殊字符，都失去它们的特殊含义，被当作普通字符来看待，双引号中参数、表达式的展开仍然有效
单引号会禁止所有的展开，内容原封不动
6. Ctrl-a：移动光标到行首；Ctrl-e：移动光标到行尾；Ctrl-k：剪切从光标位置到行尾的文本；Ctrl-u：剪切从光标位置到行首的文本。
7. 快速创建文件 > filename
8. /bin 目录是存放命令的文件
9. /boot 启动linux的核心文件
10. /etc 存放配置文件
11. /home 用户家的目录
12. /lib 动态链接共享库，依赖库
13. /opt 给主机安装额外软件所摆放的目录
14. /root 超级权限用户目录，/usr 存放用户的应用程序和文件
15. /var 存放经常变化的文件
16. 安装软件rpm、解压缩、yum


## 1.文件系统命令
	pwd 显示当前工作目录
	cd 进入目标目录 .为当前目录  ..为父级目录（默认缺省./）
	
	
## 2. 浏览目录命令
	ls 列出目录下文件及文件夹 可以列出多个目录下（ls ～ /user）
| 选项  |长选项|描述 |
| ---- | ---- | ---- |
|-a|--all|列出所有文件，甚至包括文件名以圆点开头的默认会被隐藏的隐藏文件。|
|-d|--directory|通常，如果指定了目录名，ls 命令会列出这个目录中的内容，而不是目录本身。把这个选项与-1选项结合使用，可以看到所指定目录的详细信息，而不是目录中的内容。|
|-F|--classify|这个选项会在每个所列出的名字后面加上一个指示符。例如，如果名字是目录名，则会加上一个'/字符。
|-h|--human-|当以长格式列出时，以人们可读的格式，而不是以字节数来显示文件的readable 大小。|
|-l|以长格式显示结果。|
|-r|--reverse|以相反的顺序来显示结果。通常，ls 命令的输出结果按照字母升序排列。|
|-S||命令输出结果按照文件大小来排序。|
|-t||按照修改时间来排序。|
	-rw-r--r-- 1 root root 3576296 2007-04-03 11:05 Experience ubuntu.ogg（ls -l）
	文件类型还有l：符号链接、c：字符设备文件、b：块设备文件
|字段|含义|
|----|----|
|-rw-r--r--|对于文件的访问权限。第一个字符指明文件类型。在不同类型之间，开头的“一”说明是一个普通文件，“d”表明是一个目录。其后三个字符是文件所有者的访问权限，再其后的三个字符是文件所属组中成员的访问权限，最后三个字符是其他所有人的访问权限。这个字段的完整含义将在第十章讨论。|
|1|文件的硬链接数目。参考随后讨论的关于链接的内容。|
|root|文件所有者的用户名。|
|root|文件所属用户组的名字。|
|32059|以字节数表示的文件大小。|
|2007-04-03 11:05|.上次修改文件的时间和日期。
|oo-cd-cover.odf|文件名。|
  

## 3. 浏览文件命令
	file filename （文件内容的简单描述）
	less filename（浏览文件全部内容，输入q退出浏览），less后要查找字符串输入： /要查询的字符串
	cat filename
	nl filname 带行号显示文件

## 4. 通配符
|通配符|意义|
|----|----|
|*|匹配任意多个字符(包括零个或一个)|
|?|匹配任意一个字符(不包括零个)|
|[characters]|匹配任意一个属于字符集(characters) 中的字符|
|[!characters]|匹配任意一个不是字符集中的字符|
|[[:class:]]|匹配任意一个属于指定字符类中的字符


## 5. 创建目录命令
	mkdir directory…（…意味着可以有多个参数，mkdir dir1 dir2 dir3）

## 5.复制命令
	cp item1 item2  复制item1到item2，cp  -a item1 item2
	cp item... directory
|   选项   |意义|
|--------|----|
|-a, --archive|复制文件和目录，以及它们的属性，包括拥有者和所有权。通常情况下，文件拷贝具有执行拷贝操作的用户的默认属性。|
|-i, --interactive|在覆盖已存在文件之前，提示用户确认。如果这个选项不指定，cp 命令会默认覆盖文件。|
|-r, --recursive|递归地复制目录及目录中的内容。当复制目录时，需要这个选项 (或者-a选项)。|
|-u, --update|当把文件从一个目录复制到另一个目录时，仅复制目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在文件的内容的文件。|
|-V, --verbose|显示翔实的命令操作信息|



## 6. 移动或重命名
	mv item1 item2
	mv item... directory
|选项|意义|
|----|----|
|-i --interactive|在覆盖一个已经存在的文件之前，提示用户确认信息。如果不指定这个选项，mv命令会默认覆盖文件内容。|
|-u --update|当把文件从一个目录移动另一个目录时，只是移动不存在的文件，或者文件内容新于目标目录相对应文件的内容的文件。|
|-V --verbose|当操作mv命令时，显示翔实的操作信息。|


## 7. 删除文件或目录
	rm item...
|选项|意义|
|----|----|
|-i, --interactive|在删除已存在的文件前，提示用户确认信息。如果不指定这个选项，rm会默默地删除文件|
|-r, --recursive|递归地删除文件，这意味着，如果要删除一个目录，而此目录又包含子目录，那么子目录也会被删除。要删除一-个目录，必须指定这个选项。|
|-f, --force|忽视不存在的文件，不显示提示信息。这选项覆盖了“-interactive”选项。|
|-V, --verbose|在执行rm命令时，显示翔实的操作信息。|

## 8. 创建链接
	ln file link（符号链接，ln -s item link）

## 9. which命令
	which exe（找到可执行程序exe的位置）

## 10. 帮助文档类命令
	得到shell内建命令的帮助文档
	help command（只可以是shell内部命令）或者 command --help
	cd [-L|-P] [dir]（方括号证的内容是可选的项目。一个竖杠字符 表示互斥选项。）
	显示用户手册：man program
	显示程序info条目：info coreutils

## 11. 自定义命令别名
	alias name='string’（string可为单个命令或多个命令组合）
	创建别名前，先使用type name看该别名是否已经被使用
	删除别名 unalias name

## 12. 重定向
	标准输出重定向
	ls -l /usr/bin > ls-output.txt（将标准输出结果输出到文件而不是标准输出）
	> filename（会清空已有文件或创建新文件，因为默认是清空文件，再写）
	ls -l /usr/bin >> ls-output.txt（以追加写的方式重定向，而不是从头写）

	标准错误输出重定向
	n >& m	将输出文件 m 和 n 合并。
	n <& m	将输入文件 m 和 n 合并。
	ls -l /bin/usr 2> ls-error.txt（文件描述符0，1，2分别为标准输入、输出、错误）
	ls -l /bin/usr &> ls-output.txt（将标准输出和错误同输出到一个文件或：ls -l /bin/usr > ls-output.txt 2>&1）

	标准输入重定向
	cat lazy_dog.txt（将标准输入重定向到文件，命令回撤后即可输入想要输入的字符，然后Ctrl-d退出）
	cat < lazy_dog.txt （重定向输入为文件）
	
	管道（将一个命令的标准输出送至另一个命令的标准输入）
	command1 | command2 （ls -l /usr/bin | less）
	ls /bin /usr/bin | sort | uniq | less（过滤器，先排序，再去重）

字数统计：wc filename（输出行数、单词数、字节数）

寻找匹配行：grep pattern [file…]（-i忽略大小写）

打印文件开头：head -n 5 ls-output.txt（-n 5 指定五行，不写默认十行）

打印文件结尾：tail -n 5 ls-output.txt

## 13. 展开
	Echo会把命令展开，即输出计算后的值以及匹配到的完整文件等，会对多余的空格进行去除
		echo D*（会输出所有匹配的文件， Documents Pictures Templates Videos）
		$((expression))  算术表达式，只支持整数
		echo Front-{A,B,C}-Back   （得到Front-A-Back Front-B-Back Front-C-Back）    可用于创建多个文件或文件夹
		echo Number_{1..5}       （得到 Number_1  Number_2  Number_3  Number_4  Number_5）
		echo $USER    展开参数（系统变量）
		ls -l $(which cp)    which cp得到的结果作为ls的参数
	
## 14. 查看最近输入的命令
	history | less  浏览历史命令列表
	！n      运行列表中第n条命令
|快捷键|意义|
|----|----|
|Alt-<|移动到历史列表开头。|
|Alt->|移动到历史列表结尾，即当前命令行。|
|Ctrl-r|反向增量搜索。从当前命令行开始，向上增量搜索。|
|Alt-p|反向搜索，非增量搜索。（输入要查找的字符串，按下 Enter来执行搜索）。|
|Alt-n|向前搜索，非增量。|
|Ctrl-o|执行历史列表中的当前项，并移到下一个。如果你想要执行历史列表中一系列的命令，这很方便。|

## 15. 权限
	id （uid=500(me) gid=500(me) groups=500(me)，用户id，组id）
|文件权限属性|文件|目录|
|----|----|----|
|r|允许打开并读取文件内容。|允许列出目录中的内容，前提是目录必须设置了可执行属性（x）。|
|w|允许写入文件内容或截断文件。但是不允许对文件进行重命名或删除，重命名或删除是由目录的属性决定的。|允许在目录下新建、删除或重命名文件，前提是目录必须设置了可执行属性（x）。|
|x|允许将文件作为程序来执行，使用脚本语言编写的程序必须设置为可读才能被执行。|允许进入目录，例如：cd directory 。|
	chmod 600 foo.txt（更改文件权限，只有超级用户和文件所有者才能更改，使用一个八进制数代表一类用户的权限，有就是1，没有就是0）
|数字|二进制|文件权限|
|----|----|----|
|0|000|---|
|1|001|--x|
|2|010|-w-|
|3|011|-wx|
|4|100|r--|
|5|101|r-x|
|6|110|rw-|
|7|111|rwx|
	也可以使用符号，“＋”字符，表示加上一个权限， 一个“－”，表示删掉一个权限，或者是一个“＝”，表示只有指定的权限可用，其它所有的权限被删除。
|||
|----|----|
|u|"user"的简写，意思是文件或目录的所有者。|
|g|用户组。|
|o|"others"的简写，意思是其他所有的人。|
|a|"all"的简写，是"u", "g"和“o”三者的联合。|
|u+x|为文件所有者添加可执行权限。|
|u-x|删除文件所有者的可执行权限。|
|+x|为文件所有者，用户组，和其他所有人添加可执行权限。 等价于 a+x。|
|o-rw|除了文件所有者和用户组，删除其他人的读权限和写权限。|
|go=rw|给文件所属的组和文件所属者/组以外的人读写权限。如果文件所属组或其他人已经拥有执行的权限，执行权限将被移除。|
|u+x,go=rw|给文件拥有者执行权限并给组和其他人读和执行的权限。多种设定可以用逗号分开。|

	更改身份
		su [-[l]]  [user]			不指定用户，则切换到超级用户，-l表示启动一个新的shell，而不是单切换用户执行一条命令
		su -c 'command’    不打开新的shell，只执行单个命令
		sudo command 类似su -c，但是sudo命令要求输入当前用户的密码而不是超级用户的密码

	更改文件所有者和用户组
		chown [owner][:[group]] file...

	修改密码
		passwd [user]

## 16. 进程管理
	ps     显示进程，默认显示与当前会话有关的进程
	ps -x    展示所有进程
	ps -a			显示当前终端的所有进程信息
	ps -u			以用户的信息显示相关进程
	px -aux。    显示进程所有信息
	ps -aux ｜grep 进程名字（如mysql）  查找符合条件的进程信息
	pstree -pu 以进程树的形态显示父子进程
		-p 显示父进程
		-u 用户相关的
其中stat字段为：
|||
|----|----|
|R|运行中。这意味着，进程正在运行或准备运行。|
|S|正在睡眠。进程没有运行，而是，正在等待一个事件， 比如说，一个按键或者网络分组。|
|D|不可中断睡眠。进程正在等待 I/O，比方说，一个磁盘驱动器的 I/O。|
|T|已停止. 已经指示进程停止运行。稍后介绍更多。|
|Z|一个死进程或“僵尸”进程。这是一个已经终止的子进程，但是它的父进程还没有清空它。 （父进程没有把子进程从进程表中删除）|
|<|一个高优先级进程。这可能会授予一个进程更多重要的资源，给它更多的 CPU 时间。 进程的这种属性叫做 niceness。具有高优先级的进程据说是不好的（less nice）， 因为它占用了比较多的 CPU 时间，这样就给其它进程留下很少时间。|
|N|低优先级进程。 一个低优先级进程，只有当其它高优先级进程被服务了之后，才会得到处理器时间。|
	top      动态显示进程信息
	program &    将程序放在后台运行
	%任务号 = PID
	jobs      显示从终端启动的所有任务
	fg   %n   将在jobs中任务号为n的后台任务调至前台
	bg   %n   将在jobs中任务号为n的后台任务调至后台
	Ctrl-z   暂停前台任务
	kill pid    杀死进程（其实是给进程传递终止信号）
	kill [-signal] PID...    给进程发送指定信号，默认终止
|信号代码|英文缩写|意义|
|----|----|----|
|1|HUP|挂起（Hangup）。名字来源于很久以前，那时候终端机通过电话线和调制解调器连接到 远端的计算机。这个信号被用来告诉程序，控制的终端机已经“挂断”。 通过关闭一个终端会话，可以展示这个信号的作用。在当前终端运行的前台程序将会收到这个信号并终止。许多守护进程也使用这个信号，来重新初始化。这意味着，当一个守护进程收到这个信号后， 这个进程会重新启动，并且重新读取它的配置文件。Apache 网络服务器守护进程就是一个例子。|
|2|INT|中断。实现和 Ctrl-c 一样的功能，由终端发送。通常，它会终止一个程序。|
|9|KILL|杀死。这个信号很特别。尽管程序可能会选择不同的方式来处理发送给它的 信号，其中也包含忽略信号，但是 KILL 信号从不被发送到目标程序。而是内核立即终止 这个进程。当一个进程以这种方式终止的时候，它没有机会去做些“清理”工作，或者是保存工作。 因为这个原因，把 KILL 信号看作最后一招，当其它终止信号失败后，再使用它。|
|15|TERM|终止。这是 kill 命令发送的默认信号。如果程序仍然“活着”，可以接受信号，那么 这个它会终止。|
|18|CONT|继续。在一个停止信号后，这个信号会恢复进程的运行。|
|19|STOP|停止。这个信号导致进程停止运行，而不是终止。像 KILL 信号，它不被 发送到目标进程，因此它不能被忽略。|
	killall [-u user] [-signal] name...     给多个进程发控制信号
	

## 17. 环境
	printenv （显示环境变量，通常printenv | less这样使用，也可以指定某个变量输出 printenv paramsname，或者echo $paramsname）
	或者 set | less
常见变量：
|变量|意义|
|----|----|
|EDITOR|文本编辑器的名字。|
|SHELL|shell 程序的名字。|
|HOME|用户家目录。|
|LANG|定义了字符集以及语言编码方式。|
|OLD_PWD|先前的工作目录。|
|PAGER|页输出程序的名字。这经常设置为/usr/bin/less。|
|PATH|由冒号分开的目录列表，当你输入可执行程序名后，会搜索这个目录列表。|
|PS1|Prompt String 1. 这个定义了你的 shell 提示符的内容。随后我们可以看到，这个变量 内容可以全面地定制。|
|PWD|当前工作目录。|
|TERM|终端类型名。类 Unix 的系统支持许多终端协议；这个变量设置你的终端仿真器所用的协议。|
|TZ|指定你所在的时区。大多数类 Unix 的系统按照协调时间时 (UTC) 来维护计算机内部的时钟 ，然后应用一个由这个变量指定的偏差来显示本地时间。|
|USER|你的用户名|

登陆环境变量配置文件：
|文件|作用|
|----|----|
|/etc/profile|应用于所有用户的全局配置脚本。|
|~/.bash_profile|用户个人的启动文件。可以用来扩展或重写全局配置脚本中的设置。|
|~/.bash_login|如果文件 ~/.bash_profile 没有找到，bash 会尝试读取这个脚本。|
|~/.profile|如果文件 ~/.bash_profile 或文件 ~/.bash_login 都没有找到，bash 会试图读取这个文件。 这是基于 Debian 发行版的默认设置，比方说 Ubuntu。|

非登陆环境配置文件：
|文件|作用|
|----|----|
|/etc/bash.bashrc|应用于所有用户的全局配置文件。|
|~/.bashrc|用户个人的启动文件。可以用来扩展或重写全局配置脚本中的设置。|

	添加一个环境变量，在其后加；变量值即可

	source .bashrc    生效我们修改后的配置文件（因为配置文件是在shell刚启动才读取）

## 18. VIM
	:q     退出编辑
	:q!    强制退出
	:   保存
	:w	保存后写入磁盘可以和q结合到一起
	vim filename   创建文件
	每行开头的波浪号（”~”）表示那一行没有文本
	i   进入插入模式
	a 追加模式（追加到行尾）
	A 先跳到行尾，再启动追加模式（省去了自己移动光标）
	o 在当前行下另起一行，并进去插入模式
	O 在当前行上另起一行，并进去插入模式
	u 撤销最近一次修改
删除命令：
|命令|命令含义|
|----|----|
|x|当前字符|
|3x|当前字符及其后的两个字符。|
|dd|当前行。|
|5dd|当前行及随后的四行文本。|
|dW|从光标位置开始到下一个单词的开头。|
|d$|从光标位置开始到当前行的行尾。|
|d0|从光标位置开始到当前行的行首。|
|d^|从光标位置开始到文本行的第一个非空字符。|
|dG|从当前行到文件的末尾。|
|d20G|从当前行到文件的第20行。|
	删除掉的字符被默认复制进一个缓冲区，然后可以使用小 p 命令把剪切板中的文本粘贴到光标位置之后， 或者是大 P 命令把文本粘贴到光标之前

	纯复制命令y
|命令|命令含义|
|----|----|
|yy|当前行|
|5yy|当前行及随后的四行文本。|
|yW|从当前光标位置到下一个单词的开头。|
|y$|从当前光标位置到当前行的末尾。|
|y0|从当前光标位置到行首。|
|y^|从当前光标位置到文本行的第一个非空字符。|
|yG|从当前行到文件末尾。|
|y20G|从当前行到文件的第20行。|

	连接两行
	vi 对于行的概念相当严格。通常，用户不可能通过删除“行尾结束符”来连接 当前行和它下面的一行。由于这个原因，vi 提供了一个特定的命令，大写的 J用于链接行与行。

	查找
		fcontent（查找一行，如fa，查找a）
		/content（查找整个文件）

	替换
		:%s/Line/line/g
|命令|命令含义|
|----|----|
|:|冒号字符运行一个 ex 命令。|
|%|指定要操作的行数。% 是一个快捷方式，表示从第一行到最后一行。另外，操作范围也 可以用 1,5 来代替（因为我们的文件只有5行文本），或者用 1,$ 来代替，意思是 “ 从第一行到文件的最后一行。” 如果省略了文本行的范围，那么操作只对当前行生效。|
|s|指定操作。在这种情况下是，替换（查找与替代）。|
|/Line/line|查找类型与替代文本。|
|g|这是“全局”的意思，意味着对文本行中所有匹配的字符串执行查找和替换操作。如果省略 g，则 只替换每个文本行中第一个匹配的字符串。|

	按esc退出模式，进入vim命令界面
|命令|命令含义|
|----|----|
|0 (零按键)|移动到当前行的行首。|
|^|移动到当前行的第一个非空字符。|
|$|移动到当前行的末尾。|
|w|移动到下一个单词或标点符号的开头。|
|W|移动到下一个单词的开头，忽略标点符号。|
|b|移动到上一个单词或标点符号的开头。|
|B|移动到上一个单词的开头，忽略标点符号。|
|Ctrl-f or Page Down|向下翻一页|
|Ctrl-b or Page Up|向上翻一页|
|numberG|移动到第 number 行。例如，1G 移动到文件的第一行。|
|G|移动到文件末尾。|

# Shell
		shell是一个命令行解释器，他接收应用程序、用户的命令，然后调用操作系统内核
## 格式
		以 #!/bin/bash 开头（指定解释器）
		执行 bash xxx.sh
		或者给xxx.sh 执行权限 然后xxx.sh即可
		命令以换行为分隔

## 变量
	默认变量都是字符串类型
	变量=值
	引用变量$变量名
	取消变量 unset 变量名
	只读变量 readonly 变量=值
	将变量提升为全局变量 export 变量名
### 特殊变量
	$n:$0代表脚本名称， $1-$9为传入的参数
	$#：代表参数的个数
	$*：把所有参数当作一个整体
	$@：
	$?：上一条命令执行的状态，0为成功

## 运算符
	$[运算式]
	expr 运算式（运算符两侧必须有空格）

## 条件判断
	[ condition ] [ 23 -ge 22 ]
### 整数比较
	-lt（小于）、-le（小于等于）
	-gt、-ge
	-eq、-ne
### 文件权限
	-r,-w,-x
### 文件类型判断
	-f、-d、-e

## 控制流程
### if
	if [ 条件表达式 ];then
		程序
	elif [ 条件表达式 ];then
		程序
	fi
### case
	case $变量名 in
	"值1"）
		程序
	;;
	"值2"）
		程序
	;;
	*)
		程序
	;;
	esac
### for
	for(( 初始值;循环条件;值变化 ))
	do
		程序
	done

	for 变量 in 值1 值2 值3···
	do
		程序
	done
### while
	while [ 条件判断 ]
	do
		程序
	done


